\documentclass[12pt]{article}

\usepackage{notestyle}

\graphicspath{{./img/}}


\title{Note Web Application}
\author{Brendon Mendicino}



\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage



\section{ Introduction}
 is backward compapatible, to be able to use the previous features is use the directive:
\begin{lstlisting}[language=]
"use strict";
\end{lstlisting}
JS has primitive types and non-primitive types, JS is also and strongly typed language, the primitive types are: string, number, boolean, null, undefined. The non-primitive are the objects, which can be: array, function, user-defined.

The all possible false values in JS: \texttt{0, -0, NaN, undefined, null,''}, in JS there are two main comparison operators:
\begin{lstlisting}[language=]
a == b    // equal, convert types and compare
a === b   // strict equal, inhibits automatic type conversion
\end{lstlisting}
In JS you can create variable with:
\begin{lstlisting}[language=]
// modern
let a = 10;    // can be changed
const b = 'a'; // constant

// old
var k = 9;
j = 30;
\end{lstlisting}
The difference between null and undefined, is that variable with null they old a value which is null, on the other way if a variable is declared and nothing is associated with it the value olds by default undefined.

A scope is defined by a \textbf{block}, which is created with \texttt{{ ... }}

There two kinds of \texttt{foreach} in JS, using \texttt{in} allows iterating over objects, while \texttt{of} allows iterating over iterable objects:
\begin{lstlisting}[language=]
for (let a in object) {
  ...
}

for (let b of iterable) {
  ...
}
\end{lstlisting}
Using arrays:
\begin{lstlisting}[language=]
let a = [1, 2, 'ok', false];
let b = Array.of(1, 2, true);
a.push(5);      // append an element
b.unshift(2);   // insert at the beginning

let copy = Array.from(a);  // shallow copy, it does not deep copy
\end{lstlisting}
The \textbf{destructuring assignment} can be done, it extracts the values from the mast left-hand side:
\begin{lstlisting}[language=]
let [x, y] = [1, 2];
[x, y] = [y, x]     // swap
\end{lstlisting}
The \textbf{spread operator} (\texttt{...}) expands on iterable object into it's values:
\begin{lstlisting}[language=]
let [x, ...y] = [1, 2, 3, 4];      // y == [2, 3, 4]

const a = [1, 2];
const b = [0, ...a, 3]; // [0, 1, 2, 3]
\end{lstlisting}
Spreding can be from the left or from the right, usually the spread operator is used for copying array:
\begin{lstlisting}[language=]
const a = [1, 2];
const b = [...a];
\end{lstlisting}
A \textbf{string} is JS is an immutable type (like python) encoded in Unicode. The \textbf{template literals} can be done with the \textbf{tick} operator \texttt{``} (expression like Kotlin):
\begin{lstlisting}[language=]
let name = 'Bre';
let sur = 'Mend';
// Template literal
let fullName = `${name} ${sur}`;
\end{lstlisting}


\subsection{Objects}
JS is \textbf{prototype based language}, which means that there are no declarations of classes. In JS property names must be strings and can be modified, the value of the property can be any other type of type or object. To create and object in JS you use curly braces and the defined properties:
\begin{lstlisting}[language=]
const movie = {
  title: 'Inception',
  genre: 'sci-fi',
  duration: 180
}

console.log(movie)
console.log(movie['title'])
console.log(movie.title)
\end{lstlisting}
It is also possible to add a property by simple assigning a new name to a type, it is also possible to delete a property with the keyword \texttt{delete}. There are two helper functions:
\begin{itemize}
  \item \texttt{Object.key(object)}: return only the key;
  \item \texttt{Object.entries(object)}: return an array with the key and value;
\end{itemize}
To copy an object it is possible to use:
\begin{lstlisting}[language=]
const copied = Object.assign({}, original)
const withSpread = {...original}    // it also possbible to use the spread operator

// assign can also be used to merge objects
const merged = Object.assign({}, copied, {something: 'test'})
\end{lstlisting}


\subsection{Functions}
In JS functions are objects, so it is possible to assign a function to a property or use it in a parameter in another function. There three possible ways to define a function:
\begin{lstlisting}[language=]
// 1. Function
function do(a, b = 1) {
  ...
}

// parameters can also hava a deafult value
function some(par1, par2, ...variable) { // ... is the 'rest' operator, like varargs, rest parameters can be iterated
  ...
}

// 2. Function Expression
const fn = function(params) { }

// 3. Arrow Function
const func = (params) => { }
\end{lstlisting}
In JS \textbf{Closure} can be created, with closure it is possible to use parameters of the scope where the function is defined, even if that scope does not exist any more.
\begin{lstlisting}[language=]
function greeter(name) {
  const myname = name;

  const hello = () => {
    return "Hello " + myname;
  }

  return hello;
}

const helloTest = greeter('test');

console.log(helloTest());   // 'Hello test'
\end{lstlisting}
To create an object there are also \textbf{constructor functions}:
\begin{lstlisting}[language=]
function Movie(title, director, duration) {
  this.title = title;
  this.director = director;
  this.duration = duration;
  this.isLong = () => this.duration > 120;
}

cosnt movie = new Movie('Inception', 'Nolan', 180);
console.log(movie.isLong);  // true
\end{lstlisting}

















\end{document}


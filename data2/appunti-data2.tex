\documentclass[12pt]{article}

\usepackage{notestyle}

\graphicspath{{./img/}}


\title{Appunti Database}
\author{Brendon Mendicino}



\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage


\section{Introduzione}\label{sec:introduzione}


KDD: Knowledge Discovery from Data

\paragraph{Tecniche di data mining}
\begin{itemize}
    \item Regole di associazione: usate per trovare delle relazioni frequenti all'interno del database. Ad esempio: chi compra pannolini compra anche birra, il 2$\%$ degli scontrini contegono entrambe gli oggetti, il 30$\%$ degli scontrini che contengono pannalini contengono anche birra. Grazie alle regole di associazione si possono fare dei tipi di analisi come la basket analisys, ma puo essere utile anche per le raccomanadazioni.
    \item Classificazione: i classificatori predicono etichette discrete, esempio: nella posta elettronica alcune mail vengono segnate come spam. La classificazione definisce un modello per definire le predizioni, a volte non \`e sempre possibile creare dei modelli interpretabili ovvero dare una ragione per una determinata scelta.
    \item Clustering: gli algoritmi creano dei gruppi che raggruppano gli oggetti in esame, senza per\`o dare delle motivazioni delle scelte effettuate.
\end{itemize}





\section{Data Warehouse}
Un DW  \`e una base dati di supporto alla decisioni, che \`e mantenuta separatamente dalla base di dati operativa dell'azienda. I dati al suo interno sono:
\begin{itemize}
    \item orientati ai soggetti di interesse;
    \item integrati e consistenti;
    \item dipendenti dal tempo;
    \item non volatili;
    \item utilizzati per il supporto alle decisioni aziendali;
\end{itemize}


Per la progettazione concettuale di un DW, non esiste un formalismo universale, il modello ER non \`e adatto ma viene invece utilizzata il modello \textbf{Dimensional Fact Model}.

Il DFM \`e composto da:
\begin{itemize}
    \item Fatto: modella un insieme di eventi di interesse, che evolvono nel tempo (che pu\`o overe diversa granuralit\`a).
    \item Dimensioni: sono gli attribuiti di un fatto, generalmento sono categorici.
    \item Misure: discrive una caratteristica numerica di un fatto.
\end{itemize}
Sulle dimensioni si possono definire delle gerarachie, che definiscono di fatto una dipendenza funzionale tra gli attributi, quindi di 1 a n. Ad esempio: \textbf{data} ha un arco \textbf{mese}, una data ha uno ed un solo mese (1 a n).

I costrutti avanazati sono:
\begin{itemize}
    \item archi opzionali;
    \item dimensioni opzionali;
    \item attributo descrittivo: sono delle informazioni utili all'utente ma su cui non verteranno le interragazioni (ad esempio non si far\`a mai la group by su un indirizzo);
    \item non-additivit\`a: non si pu\`o fare la somma sulla metrica, il motivo \`e che non \`e modellato in modo tale da fare la somma;
\end{itemize}




\begin{itemize}
    \item Fatto: fenomeno di studio;
    \item Misure: attributi del fatto;
    \item Dimensioni: tabelle collegate al fatto;
\end{itemize}


\textbf{Schema a stella}:


\textbf{Snoflawke scheme}: si esplicitano le dipendenze funzionali, questo per\`o comporta un aumento delle operazioni di join.

Nella realt\`a lo snowflake \`e raramente utilizzato, il motivo \`e che il costo delle join pu\`o diventare oneroso. Un caso di utilizzo dello snowflake \`e quando si hanno dei dati condivisi.

\textbf{Archi multipli}:


\textbf{Dimensioni degeneri}: sono delle dimensioni con un solo attributo, questo si perch\`e nello stato attuale non si hanno delle specifiche per quell'attributo ma nel futuro si potrebbe facilmente estendere. Un'altra soluzione potrebbe essere un push down delle dimensioni degeri nella tabella dei fatti.

\textbf{Junk Dimension}: si pu\`o creare una dimensione che contenga tutte le dimensioni degeneri, le informazioni sono collegate semanticamente, \`e anche possibile unire delle informazioni scorrelate ma non \`e una scelta poco corretta, una soluzione potrebbe essere avere pi\`u junk dimensions.


\section{Analisi}
Sfruttando solo l'SQL \`e molto difficile fare delle analisi su un dw, infatti volendo calcolare delle operazioni per due argomenti diversi si devono fare pi\`u query. Estendendo il SQL si pu\`o, ad esempio, effettuare pi\`u operazioni leggendo una sola volta la tabella, ed effettuando il minor numero di join possibile.

\paragraph{Analisi OLAP}
I tipi di operazione sono:
\begin{itemize}
    \item roll up: riducendo il livello di dettaglio del dato, ovvero eliminare una o pi\`u clausole della groupby o navigare la gerarchia verso l'esterno;
    \item drill down: si aumenta il livello di dettaglio oppure si aggiunge una dimensione di analisi;
    \item slice and dice: consentono di ridurre il volume dei dati selezionando un sottogruppo dei dati di partenza;
    \item tabelle pivot: come viene mostrato il dato;
    \item ordinamento: ordinamento in base agli attributi;
\end{itemize}
Queste operazioni possono essere fatte con pi\`u o una query.

\subsection{Finestra di calcolo}
Una finestra di calcolo fa dei calcoli a partire da una query sottostante, la finestra ha 3 operazioni sottostanti:
\begin{itemize}
    \item partizionamento (\textbf{partition by}): partizionamnto dei dati, divide i record in gruppi a partire dall'attributo selezionato;
    \item ordinamento (\textbf{order by}): si definisce il criterio di ordinamento delle righe all'interno dei partizionamenti;
    \item finestra di aggregazione (\textbf{over}): porzione di dati, specifica per ogni riga di dato, su cui effettuare dei calcoli;
\end{itemize}
\begin{example}{}{}
    Data la tabella Vendite(\underline{Citt\`a}, \underline{Mese}, Importo), calcolare per ogni citt\`a la media delle vendite per il mese corrente ed i due precedenti.

\begin{lstlisting}[language=sql]
SELECT Citta, Mese, Importo,
    AVG(Importo) OVER (PARTITION BY Citta)
                        ORDER BY Mese
                        ROWS 2 PRECEDING)
    AS MediaMobile
FROM Vendite;
\end{lstlisting}
\end{example}
Quando la finestra \`e incompleta il calcolo \`e effettuato sulla parte presente, \`e possibile specificare che se la riga non \`e presente il risultato deve essere NULL.

Si pu\`o definire un intervallo fisico, superiore o inferiore. 
\begin{lstlisting}[language=sql]
    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
\end{lstlisting}
\`E possibile definire la tupla currente e quella che la precedono e che la seguono
\begin{lstlisting}[language=sql]
ROWS UNBOUNDED PRECEDING (o FOLLOWING)
\end{lstlisting}
Il rggruppamento fisico \`e specifico per quando i dati non hanno delle interruzioni.


Per definire un intervallo logico si utilizza il costrutto \textbf{range}.

\begin{lstlisting}[language=SQL]
SELECT Citta, Mese, Importo,
    Importo / SUM(Importo) OVER () AS PerOverMax,
    Importo / SUM(Importo) OVER (PARTITION BY Citta) AS PerOverCity,
    Importo / SUM(Importo) OVER (PARTITION BY Mese) AS PerOverMonth
FROM Vendite
\end{lstlisting}


Se una \textbf{group by} \`e presente all'interno della query allora, tutte le entry che possono comparire nella finestra di calcolo sono solo quelle che compaiono nella group by.

\paragraph{Funzione di ranking}
La funzione di ranking serve a creare delle classifiche

\begin{itemize}
    \item \textbf{rank()}: la funzione rank in presenza di pi\`u oggetti nella stessa posizione salta al prossimo record;
    \item \textbf{denserank()}: la funzione denserank tiene tutte righe con la stessa posizione;
\end{itemize}

...
\begin{lstlisting}[language=sql]
SELECT Citta, Mese, SUM(Importo) AS TotMese,
    RANK() OVER (PARTITION BY Citta
                ORDER BY SUM(Import) DESC)

FROM Vendite, ...
WHERE ...
GROUP BY Citta, Mese
\end{lstlisting}



\paragraph{Estensione della group by}
\begin{itemize}
    \item \textbf{rollup}: consente di calcolare le aggragazioni su tutti i possibili gruppi, eliminando una colonna alla volta, da destra verso sinistra, esempio: calcola le vendite per: (Citta, Mese, Prodotto), (Citta, Mese), (Citta):
        \begin{lstlisting}[language=sql]
SELECT Citta, Mese, Prodotto, SUM(Importo) AS TotVendite
FROM ...
WHERE ...
GROUP BY ROLLUP (Citta, Mese, Prodotto)
        \end{lstlisting}
    \item \textbf{cube}: consente di calcolare tutte le possibili combinazioni del ragrruppamento;
    \item \textbf{grouping sets}: serve a definire degli aggregati su gruppi specifici definiti dall'utente;
\end{itemize}


\subsection{Sintassi ORACLE}
Raggruppamento fisico:
\begin{example}{}{}
    Selezionare, separatamente per ogni citt\`a, per ogni data l'importo e la media dell'importo dei due giorni precedenti.
    \begin{lstlisting}[language=sql]
select citta, data, importo,
    avg(importo) over (partition by citta
                        order by data
                        rows 2 preceding
    ) as mediaMobile
from vendite
order by citta, data;
    \end{lstlisting}
\end{example}


Raggruppamento logico:
\begin{example}{}{}
   \begin{lstlisting}[language=sql]
select citta, data, importo,
    avg(importo) over (PARTITION BY citta
                        ORDER BY data
                        RANGE BETWEEN INTERVAL '2'
                        DAY PRECEDING AND CURRENT ROW
    ) as mediaUltimi3Giorni
from vendite
order by citta, data;
   \end{lstlisting}
\end{example}

\begin{example}{}{}
    \begin{lstlisting}[language=sql]
select COD_A, sum(Q) as sommaPerArticolo,
    rank() over (order by sum(Q) desc) as graduatoria
from FAP
group by COD_A
    \end{lstlisting}
\end{example}


All'interno di oracle sono preseti delle funzionalit\`a aggiuntive oltre alla funzione di rank, come: 

\paragraph{ROW\_NUMBER}
Assegno un numero progressivo ad ogni elemento in una partizione.

\begin{lstlisting}[language=sql]
select tipo, peso,
    row_number over (partition by tipo
                    order by tipo)
from ...
where ...;
\end{lstlisting}

\paragraph{CUME\_DIST}
Consente di calcolare le distribuzine cumulativa all'interno di una partizione, permette di definire un valore sulla distribuzione dei valori.


\paragraph{NTILE(n)}
Una funzione che da la possibilit\`a di dividere le partizioni in sottogruppi
\begin{lstlisting}[language=sql]
select tipo, perso, 
    ntile(3) over (partition by tipo order by peso) as ntile3peso
from ...
where ...;
\end{lstlisting}



\subsection{Esercizi}
Cliente(CodCliente, Cliente, Provincia, Regione) \\
Categoria(CodCat, Categoria) \\
Agente(CodAgente, Agente, Agenzia) \\
Tempo(CodTempo, Mese, Trimestre, Semestre, Anno) \\
Fatturato(CodTempo, CodCliente, CodCatArticolo, CodAgente, TotFatturato, NumArticoli, TotSconto) 

\vspace{.8cm}

1. Visualizzare per ogni categoria di articoli
\begin{itemize}
    \item la categoria
    \item la quantità totale fatturata per la categoria in esame
    \item il fatturato totale associato alla categoria in esame
    \item il rank della categoria in funzione della quantità totale fatturata
    \item il rank della categoria in funzione del fatturato totale
\end{itemize}
\begin{lstlisting}[language=sql]
select categoria, sum(numArticoli),
    sum(totFatturato),
    rank() over (order by sum(numArticoli) desc),
    rank() over (order by sum(totFatturato) desc)
from fatturato f, categoria c
where f.codCatArticolo = c.codCat
group by categoria;
\end{lstlisting}
2. Visualizzare per ogni provincia
\begin{itemize}
    \item la provincia
    \item la regione della provincia
    \item il fatturato totale associato alla provincia
    \item il rank della provincia in funzione del fatturato totale, separato per regione
\end{itemize}
\begin{lstlisting}[language=sql]
select provincia, regione,
    sum(totFatturato) as fatturatoPerProvincia,
    rank() over (partion by regione
                 order by sum(totFatturato) desc
    ) as rankFatturatoPerRegione
from cliente c, fatturato f
where c.codCliente = f.codCliente
group by provincia, regione;
\end{lstlisting}
3. Visualizzare per ogni provincia e mese
\begin{itemize}
    \item la provincia
    \item la regione della provincia
    \item il mese
    \item il fatturato totale associato alla provincia nel mese in esame
    \item il rank della provincia in funzione del fatturato totale, separato per mese
\end{itemize}
\begin{lstlisting}[language=sql]
select provincia, regione, mese,
    sum(totFatturato) as fatturatoPerProvinciaPerMese,
    rank() over (partition by mese
                order by sum(totFatturato)
    ) as rankFatturatoPerMese
from cliente c, fatturato f, tempo t
where c.codCliente = f.codCliente and t.codTempo = f.codTempo
group by provincia, regione, mese;
\end{lstlisting}
4. Visualizzare per ogni regione e mese
\begin{itemize}
    \item la regione
    \item il mese
    \item il fatturato totale associato alla regione nel mese in esame
    \item l’incasso cumulativo al trascorrere dei mesi, separato per ogni regione
    \item l’incasso cumulativo al trascorrere dei mesi, separato per ogni anno e regione
\end{itemize}
\begin{lstlisting}[language=sql]
select regione, mese,
    sum(TotFatturato) as fatturatoPerMese,
    sum(TotFatturato) over (
        partition by regione
        order by mese
        rows unbounde preceding
    ) as incassoCumulativoTot,
    sum(TotFatturato) over (
        partition by regione, anno
        order by mese
        rows unbounded preceding
    ) as incassoCumulativoPerAnno
from cliente c, fatturato f, tempo t
where c.CodCliente = f.CodCliente and t.CodTempo = f.CodTempo
group by regione, mese, anno;
\end{lstlisting}



\newpage
\section{Viste materializzate}
Le viste materializzate sono necessarie per ridurre la lentezza della operazioni di group by per grandi moli di dati, le viste materializzate sono dei sommari precalcolati della tabella dei fatti.

Le VM usano con con costruto pricipale la group by, quando si crea una VM \`e convienente includere anche le dimensioni a granularit\`a superiori, in modo da poter riutilizzare la tabella.

Per rappresetnare le dipendenze delle viste materializzate si utilizza un \textbf{reticolo multidimensionale}. Pi\`u ci si trova in alto al reticolo pi\`u ci si avvina alle dimensioni della tabella dei fatti, pi\`u si va in basso pi\`u si trova un granuralit\`a maggiore.

La scelta delle viste viste tra tutte le possibili combinazioni \`e data da:
\begin{itemize}
    \item si scelgie una sola vista da cui \`e possibile raggiungere tutti gli attributi;
    \item creo una vista per ogni query;
    \item scelgo delle viste intermedie che possono portare a ripsondere e pi\`u query;
\end{itemize}

\subsection{Documentazione Oracle}
Riducono i tempi di esecuzione delle group by e non si eseguono pi\`u le join. Nel DBMS Oracle esiste la \textbf{query rewriting}, che permette grazie all'ottimizzatore di interpretare le query e se i risultati corrispondono alle condizioni di creazioni delle viste, allora le query viene riscritta con la vista.
\begin{lstlisting}[language=sql]
create materialized view NAME
[build {immediate|deferred}]
[refresh {complete|fast|force|never}
         {on commit|on demand}]
[enable query rewrite]
as
    QUERY
\end{lstlisting}
\begin{itemize}
    \item immediate: lo schema della tabella viene popolata immediatamente, dato dallo schema di attributi presenti nella select;
    \item deferred: la vista viene creata, ma viene popolata successivamente;
    \item complete: i dati vengono presi interamente dal database;
    \item fast: i dati vengono presi in modo incrementale;
    \item force: se possibile viene eseguito il refresh in modalit\`a fast, oppure in modalit\`a complete;
    \item never: la vista non viene mai aggiornata;
    \item on commit: ogni volta che viene fatto un commit sulla tabella della query anche la vista viene aggiornata;
    \item on demand: viene definito dall'utente quando aggiornare la vista;
    \item enable query rewrite: abilita il dbms ad usare la vista per accellerary le query;
\end{itemize}

Per effetturare il refresh esistono dei tipi di job (a differenza del tipo di prodotto). Quando abbiamo bisogno del fast refresh, la tabella ha bisogno delle informazioni aggiuntive, ovvero dei file di log che ci informano delle nuove informazioni aggiunte al db, la \textbf{materialized view log} \`e associata ad una tabella che ha subito delle variazioni:
\begin{lstlisting}[language=sql]
create materialized view log on
    TABELLA
with sequence, rowid
    (Attributo, ...)
including new values;
\end{lstlisting}
\begin{itemize}
    \item squence: istante temporale in cui \`e avvenuta la modifica;
    \item rowid: indica la tupla che ha subito una modifiche;
\end{itemize}
Su queste keyword si deve difinire una lista di attributi da monitorare, si aggiunge \textbf{including new values} per supportare l'inserimento di nuove tuple.



\newpage
\section{Progettazione fisica}
Fare una progettazione fisica comporta analizzare il carico di
Si difiniscono delle strutture fisiche accessorie per velocizzare le operazioni. Si possono definire delle viste oppure degli indici, ad esempio: indici bitmap, indice di join, ...

La progettazione fisica \`e dipendente dal carico di lavoro. 

La progettazione fisica \`e caratterizzata da una fase di tuning, utilizzata per testare gli indici e le viste create e decidere se matenerli o meno. 

Gli inidici si possono creare sugli attributi che vengono selezionati pi\`u frequentemente, se il dominio \`e ridotto (come quelle categorici dei DW) si utilizza un a bitmap, altrimenti un B-tree.


\newpage
\section{Alimentazione dei Data Warehouse}
Essendo dei dati derivati, la prima operazione da effettuare \`e l'ETL, se questo \`e complesso si va a definire un area di staging in cui il dato viene matenuto temporaneamente. Il processo di ETL va gestito sei per il popolamento del DW sia per quando verr\`a aggiornato con dati nuovi.

\subsection{Estrazione}
L'estrazione statica \`e la prima estrazione effettuata per popolare il DW. Per fare l'estrazione incrementale si possono:
\begin{itemize}
    \item creare delle applicazioni ad hoc per i sistemi legacy;
    \item usando dei log, che non vanno ad interferire con il carico del db;
    \item usando dei trigger: sono proceddure che si attivano quando degli si effettuano delle operazioni specifiche;
    \item basata su timestamp: dove i recordi hanno il timestamp dell'ultima modifica effettuata su di essi;
\end{itemize}

\subsection{Pulitura}
Quando si effettua una estrazione ci si potrebbe trovare di fronte a:
\begin{itemize}
    \item dati duplicati;
    \item dati mancanti;
    \item campo non previsto;
    \item valori errati o impossibili;
    \item inconsistenza del valore;
\end{itemize}
Ogni errore richede una tecnica specifica per essere risolto, le pi\`u comuni sono l'uso di dizionari per controllare errori di battitura, oppure il \textbf{join approssimato}, ad esempio: due database non hanno una chiave condivisa per identificare un utente dall'ordine effettutato, allora per fare una join si dovranno prendere i campi comuni, controllandone sempre la consistenza, oppure i problemi di \textbf{merge/purge}, ad esmpio: facendo il merge di due db le informazioni potrebbero essere duplicate ...

\subsection{Trasformazione}
Conversione dei dati nel formato di quelli presenti nel data warehouse.

\subsection{Caricamento}
In fase di caricamento i dati si caricano nel seguente ordine:
\begin{itemize}
    \item dimensioni;
    \item fatti;
    \item indici e viste;
\end{itemize}




\begin{problem}{Progettazione Magazzini}{progettazione-magazzini}
    \hbadness=99999
    Tabelle: \\
    \texttt{UsoMtqMagazzino(\underline{codMa}, \underline{codT}, mtqLiberi, mtqTot) \\
    UsoProdMagazzino(\underline{codMa}, \underline{codMo}, \underline{codT}, numeroProdottiTotale, valoreTotaleProdotii) \\
    Tempo(\underline{codT}, data, mese, 3m, 4m, 6m, anno) \\
    Magazzino(\underline{codMa}, magazzino, citta, provincia, regione) \\
Modello(\underline{codMo}, modello, categoria)}

    Query:
    \begin{enumerate}
        \item Relativamente al primo trimestre dell’anno 2013, considerando solo i magazzini della città di Torino,trovare per ogni coppia (magazzino,data) il valore complessivo di prodotti presenti in tale data nelmagazzino e il valore complessivo medio giornaliero di prodotti presenti nel magazzino nel corsodella settimana precedente la data in esame (data in esame inclusa):
\begin{lstlisting}[language=sql]
select magazzino, data,
    sum(valoreTotProdotti) as valoreTot,
    avg(
        sum(valoreTotProdotti) over (
            partition by magazzino, data
        )
    ) over (
        partition by magazzino
        order by data
        range between interval '1'
        week preceding and current row
    ) as valoreMedioSuGiornoCorrenteESettimanaPrecedente

from UsoProdMagazzino u, Tempo t, Magazzino m
where u.codT = t.codT and
    u.codMa = m.codMa and
    citta = 'torino' and
    anno = 2013 and
    3m = 1
group by magazzino, data;
\end{lstlisting}
        \item Relativamente all’anno 2004, trovare per ogni coppia(città,data) la percentuale di superficie liberagiornaliera nella città. Associare ad ogni coppia un attributo di rank legato alla percentuale disuperficie libera giornaliera nella città (1 per la coppia con la più bassa percentuale di superficielibera giornaliera).
\begin{lstlisting}[language=sql]
select citta, data,
    sum(mtqLiberi) / sum(mtqTot) * 100 as percentualeMtqLiberi,
    rank() over (
        partition by citta, data
        order by sum(mtqLiberi) / sum(mtqTot) * 100
    ) as rankLowestPercentuale
from Tempo t, Magazzino m, UsoMtqMagazzino u
where t.codT = u.codT and
    m.codMa = u.codMa and
    anno = 2004
group by citta, data;
\end{lstlisting}
        \item Relativamente ai primi sei mesi dell’anno 2014, trovare per ogni coppia (magazzino,data) la percentuale di superficie libera giornaliera.
\begin{lstlisting}[language=sql]
select magazzino, data,
    100 * sum(mtqLiberi) / sum(mtqTot) as percentualeMtqLiberi
from Tempo t, Magazzino m, UsoMtqMagazzino u
where t.codT = u.codT and
    m.codMa = u.codMa and
    anno = 2014 and
    mese <= 6
group by magazzino, data;
\end{lstlisting}
        \item Relativamente all’anno 2013, trovare per ogni coppia (magazzino,mese) il valore complessivo medio giornaliero di prodotti presenti.
\begin{lstlisting}[language=sql]
select magazzino, mese,
    avg(
        sum(valoreTotProdotti) over (
            partition by magazzino, data
        )
    ) over (
        parition by magazzino, mese
    ) as valoreMedioGiornalieroComplessivo
from UsoProdMagazzino u, Tempo t, Magazzino m
where u.codMa = m.codMa and
    u.codT = t.codT and
    anno = 2013
group by magazzino, mese, data;
\end{lstlisting}
        \item Relativamente all’anno 2015, trovare per ogni regione il valore complessivo medio giornaliero di prodotti presenti nella regione.
\begin{lstlisting}[language=sql]
select regione, mese,
    avg(
        sum(valoreTotProdotti) over (
            partition by regione, data
        )
    ) over (
        parition by regione, mese
    ) as valoreMedioGiornalieroComplessivo
from UsoProdMagazzino u, Tempo t, Magazzino m
where u.codMa = m.codMa and
    u.codT = t.codT and
    anno = 2015
group by regione, mese, data;
\end{lstlisting}
        \item Relativamente all’anno 2014, trovare per ogni coppia(mese, regione) la percentuale di superficie libera giornaliera nella regione.
\begin{lstlisting}[language=sql]
select regione, mese,
    avg (
        100 * sum(mtqLiberi) over (
            partition by regione, data
        ) / sum(mtqTot) over (
            partition by regione, data
        )
    ) over (
        partition by regione
    )
from UsoMtqMagazzino u, Tempo t, Magazino m
where u.codMa = m.codMa and
    u.codT = t.codT and
    anno = 2014
group by regione, mese, data;
\end{lstlisting}
    \end{enumerate}
\end{problem}










\end{document}

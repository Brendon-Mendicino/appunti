\documentclass[12pt]{article}

\usepackage{notestyle}

\graphicspath{{./img/}}


\title{Notes Cryptography}
\author{Brendon Mendicino}



\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage



\section{Introduction}
Ho voglia di piangere

\begin{definition}{Modulo Operator}{modulo-operator}
  \begin{align*}
    & a = b \pmod{n} : b = n \cdot q + a \\
    & a, b, q, n \in \mathbb{Z}
  \end{align*}
\end{definition}
\begin{definition}{Congurnce Modulo n}{congurnce-modulo-n}
  \begin{align*}
    & a \equiv b \pmod{n} \\
    & a \pmod{n} = b \pmod{n}
  \end{align*}
\end{definition}


\begin{example}{}{}
  Show that $ a \equiv b \pmod{n}$ if and only if $n$ divides $a - b$.
  \begin{proof}
    \[ r  = a \pmod{n} \implies a = aq + r, \quad q \in \mathbb{Z} \] 
    \[ a \pmod{n}  = b \pmod{n} = x \]
    \[ b  = nq_1 + x, a = nq_2 + x \]
    \[ \frac{b-a}{n}  = \frac{nq_1 + x - (nq_2 + x)}{n} = q_1 - q_2 \]
    \[ \boxed{ q_1, q_2  \in \mathbb{Z} \implies \frac{b-a}{n} \in \mathbb{Z} } \]
  \end{proof}
\end{example}

\subsection{Symmetric Cryptography}
A symmetric cryptosystem $\Pi$ consist of three algorithms:
\begin{itemize}
  \item Decryption
  \item Encryption
  \item Generation
\end{itemize}
\begin{definition}{IND-secure}{ind-secure}
  A system $\Pi$ can be defined \textbf{IND-secure} if, given two plain-text as inputs $(P_0, P_1)$ to $\Pi$ and by randomly choosing one of them, there is no better chance of $0.5$ to determine whether the ciphertext was generated from $P_0$ or $P_1$.
\end{definition}




\section{Randomness}
In mathematics there is no definition for randomness, in a paper published by Lehmer (1951) tries to give an idea of what random numbers can be: \emph{"A pseudo-random is a vague notion embodying the idea of a sequence in which each term is unpredictable and whose digits pass a certain test"}. One the methods involving random number is the \textbf{Monte Carlo} used, for example, in the computation of differential equation or the computation of $\pi$.

By Lehmar one way of computing a sequence is:
\[ u_n = f(u_{n-1}, u_{n-2}, \dots, u_{n-k}); \]
By using recursion it's possible to get the next number.
\begin{definition}{Lehmar Generator}{lehmar-generator}
  \begin{align*}
    & s_0 = \text{seed} \\
    & s_{i+1} \equiv a \cdot s_i + b \pmod{m}, i \in \mathbb{N}
  \end{align*}
\end{definition}
\begin{example}{rand() in ANSI C}{rand-in-ansi-c}
  \begin{align*}
    & s_0 = 12345 \\
    & s_{i+1} \equiv 1103515245 \cdot s_i + 12345 \pmod{2^{31}}, i \in \mathbb{N}
  \end{align*}
\end{example}
\begin{definition}{Pseudo Random Generator Function}{pseudo-random-generator-function}
  Where: $\mathbb{Z}_2 = {0, 1}$, which is a binary number, $\mathbb{Z}_2^{m} = [{0,1},\dots,{0,1}]$ is sequence of bits.

  PRNG is defined as:
  \[ G: \mathbb{Z}_2^{n} \rightarrow  \mathbb{Z}_2^{l(n)}, l(n) > n \text{(expansion factor)} \]
  Such that no adversary can succeed with probability $> 1/2$ if: given a sequence of random numbers that the cryptographer has, by flipping a coin he sends to the adversary:
  \begin{itemize}
    \item 0: sends a sequence $\mathbb{Z}_2^{l(n)}$ of random bits;
    \item 1: sends a sequence $\mathbb{Z}_2^{l(n)}$ of bits created with $G$, staring from $\mathbb{Z}_2^{n}$ random bits;
  \end{itemize}
  If the adversary can guess with probability $> 1/2$ if $G$ function is used then $G$ is \textbf{IND-secure}.
\end{definition}




\subsection{Stream Cipher}
There are two operation modes with stream cipher:
\begin{itemize}
  \item \textbf{synchronized mode}:
  \item \textbf{unsynchronized mode}:
\end{itemize}

\begin{definition}{Concatenation}{concatenation}
  \begin{align*}
    Enc_k(m_j) &= \text{bits of }IV_j || G(k, IV_j, 1^{|m_j|}) \\
    & <IV_j, G(k, IV_j, 1^{|m_j|}) \bitsetXor m_j>
  \end{align*}
  $1^{|m_j|}$ = unary notation, it means passing the length of the sequence of bits (it interpreted in base 1, which means that there are as much 1s as the length of the bits required).
\end{definition}


\subsection{Linear Feedback Shift Register}
In order to construct the bit stream, let's say there are $m$ registers which contain a single bit, at every clock the next bit of the key stream is extracted from the last register, also at every clock every register is shifted to the left. When shifting there is feedback loop that, when shifting, computes the next value of the initial register. One way of accomplishing this is using the \textbf{Fibonacci LFSR}.

The output is computed by:
\[ s_m = f(\vv{s}) = \sum_{j=0}^{m-1} s_j \cdot p_j \]
The coefficients are called \textbf{taps}, they resemble the way a tap opens or closes.

If we have LFSR 










\section{Openssl}
Openssl has two versions 1.x and 3.x and 1.x will be dropped soon, but many applications still use it. The low level software implementations of the algorithm was a big mess, so a layer was created on top of it called \emph{EVP Crypto API}, that just takes in the parameters and does a translation handling all the data.



Typical use of openssl:
\begin{enumerate}
  \item include libraries
  \item load facilities: load the functions required
  \item create the context: select the tools, like a certain symmetric algorithm
  \item initialize the context: assign IV, nonce, key...
  \item operate on the context: provide the data on which the machine will work
  \item finalize on the context: perform the concluding operations on the last output, like putting the padding, or the length of the digest
  \item free the context: all the objects are \emph{one time objects}, at the end of the operations the objects need to be freed;
  \item free facilities
\end{enumerate}
Usually the mode of use of the libraries is the incremental mode, which allow get small blocks a data encrypted.

To get an object the library is called which will return the function pointer to the implementation.
\begin{lstlisting}[language=c]
EVP_CHIPER *c = EVP_bf_cbc();
\end{lstlisting}

























\end{document}

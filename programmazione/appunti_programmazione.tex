\documentclass[12pt]{article}

\usepackage{notestyle}

\graphicspath{{./img/}}


\title{Notes Software Engineering}
\author{Brendon Mendicino}



\begin{document}

\maketitle
\newpage
\tableofcontents




\newpage
\section{Memoria}
La memoria si compone si suddivide in:
\begin{itemize}
  \item registri;
  \item cache
  \item memoria primaria;
  \item memoria secondaria;
\end{itemize}
Uno principali problemi di accesso alla memoria \`e quello di assicurarne la sua protezione, ovvero evitare che un programma in memoria riesca ad accedere alle zone di memoria di altri programmi. Una volta fatto il bootstrap del SO, sia esso che i programmi verranno caricati in memoria, per evetire che ogni processo abbia una vista al di fuori del suo scope, si possono usare dei controlli a livello della CPU, esistono dei registri chimati \textbf{base} e \textbf{limit}, che attraverso dei meccanismi, riescono ad effettuare la protezione della memoria. Esiste anche un altro problema che \`e quello \textbf{relocation}, consiste nel come mappare gli indirizzi delle varie istruzioni di salto e dei vari puntari una volta che il programma viene caricato in memoria, se si utilizzaro degli indirizzi statici (creati solo in fase di compilazione e prendondo come riferimento di inizio del programma l'indirizzo 0), una volta che questo viene caricato in memoria le istrizioni non punterebbero pi\`u alle label corrispondenti  ma sempre nello stesso punto, dove ad esempio si trova un altro programma. Per questo motivo quando si utilizzano valori di registri vengono sommati al base register, mentre le boundry del programma in memoria vengono salvate nel limit.
% TODO:  <27-02-23, yourname> rivedere %
Binding ...
Si fa:
\begin{itemize}
  \item \textbf{in compilazione}: fatto quando molto semplice, ad esempio quando esistono solo due programmi;
  \item \textbf{in fase di load}: viene fatta la rilocazione durante il caricamento in memoria;
  \item \textbf{in esecuzione}: viene fatto il binding degli indirizzi in modo dinamico;
\end{itemize}
Per risolver questo problema ci si affida all'hardware, che \`e incaricato di fare la traduzione: l'indirizzo rimane lo stesso (logico) all'interno del processore, prima di arrivare all'address bus viene tradotto in indirizzo fisico, esiste dunque una dicotomia di indirizzo logico e fisico, in questo modo quando si scrive un programma, l'indirizzo parte sempre da 0. Esistono due tipi di indirizzamento che sono di tipo logico, dove l'intervallo degli indirizzi utilizzabili \`e logico, ed un indirizzamento fisico, dove il range \`e limitato dalla memoria del sistema. Per effettuare questa traduzione da indirizzo fisico a indirizzo logico e viceversa si utilizza una \textbf{MMU} (Memory Management Unit). Il modo pi\`u facile per realizzare una MMU, \`e quello di usare un \textbf{relocation register}, ovvero un registro che contiene il valore da aggiungere un indirizzo logico per fare un indirizzo fisico, il modello pi\`u semplice di MMU \`e fatto da un sommatore ed un comparatore.

Per aumentare le prestazioni ed usare la memoria in modo pi\`u efficente si possono usare delle tecniche dinamiche.
\begin{itemize}
  \tolerance=1000
  \item Si parla di \textbf{dynamic loading} quando, un programma viene caricato in memoria principale in modo frammentato, utilizzando solo i componenti che effettivamento vengono chiamati;
  \item Si parla di \textbf{dynamic linking} quando i file che contengono le funzioni che devono essere linkate (come le librerie standard) non vengono inserite all'interno dell'eseguibile, ma gli indirizzi vengono risolti in modo dinamico durante l'esecuzione;
  \item Il \textbf{link statico} \`e quando si crea un eseguibile con tutte le funzioni dentro, di fatto il loader carica tutto quando in memoria.
\end{itemize}
Il \textbf{dynamic loading} vuol dire che una routine non \`e caricata finch\'e non \`e necessaria, questo pu\`o essere fatto quando il programmatore ne \`e consapevole, infatti il processo di load non \`e trasparente:
\begin{lstlisting}[language=c]
void myPrinf(**args) {
  static int loaded = 0;
  if (!loaded) {
    load("printf");
    loaded = 1;
  }
  printf(args);
}
\end{lstlisting}
% TODO:  <27-02-23, yourname> rivedere %
Il \textbf{linker-assisted DL} si usa una chiamata fasulla che prima chiama la load, usando una \textbf{stub}.

Le \textbf{shared libraries} sono in grado di condividere le risorse, infatti se pi\`u processi utilizzano la stessa funzione essa viene messa a disposizione e per ogni nuova chiamata non ci sar\`a bisogno di chiamre una load.


Come si alloca memoria per un programma (immagine)? La pi\`u semplice \`e l'allocazoine contigua, dove si vede la RAM come due partizioni, una per il SO una per i processi (indirizzi pi\`u alti), per caricare un processo si parte da un indirizzo di inzio ed un indirizzo di fine, la MMU vista prima funziona solo con i casi di allocazione contigua (basilare). L'\textbf{allocazione contigua con paritizione variabile}: quando ci sono pi\`u buchi ci sono delle politiche differnti per inserire nuovi programmi:
\begin{itemize}
  \item \textbf{first-fit}: il primo che si trova;
  \item \textbf{best-fit}: il buco con la dimensione pi\`u piccola;
  \item \textbf{worst-fit}: il buco can li dimesnione pi\`u grande;
\end{itemize}
La frammentazione \`e sparsit\`a dei buchi all'interno della memoria. Si dice \textbf{esterna} perch\'e \`e al di fuori dei processi, si dice \textbf{interna} quando \`e interna al processo, ovvero che ha pi\`u memoria di quello che serve. La frammentazione ha bisongo di \textbf{compattazione}, il SO sposta i pezzi e poi si riparte, partitione della memoria in zona libera e zona occuputa, per fare una \textbf{deframmentazoine} (o compattazione) voul di re creare solo due partizioni (parte processi e zona libera), per effettuare la compattazione bisogna che i processi si possano spostare, inoltre un processo non pu\`o essere spostato se in quel momento il processo sta effettuando delle operazioni di IO, una soluzione per il problema dell'IO \`e il \textbf{latch job} in cui quella parte non pu\`o essere spostata, oppure si utilizza un \textbf{buffer IO del kernel}, si fa IO solo in buffer del sistema operativo.

\tolerance=1000
Con \textbf{backing store} si definisce uno spazio della memoria secondaria in cui non si salvano programmi ma vengono immagazzinati dei dati che altrimenti dovrebbero andare in RAM.

La \textbf{Paginazione} risolve i problemi della allocazione continua, rimuovendo l'allocazione contigua al suo posto si utilizzano della pagine, che sono l'unit\`a minima di allocazione, questo risolve il problema della frammentazione.
\begin{definition}{Pagine}{pagine}
  Le partizioni della memoria logica.
\end{definition}
\begin{definition}{Frame}{frame}
  Le partizioni della memoria fisica.
\end{definition}
\begin{definition}{Blocco}{blocco}
  ...
\end{definition}
Tipicamente la loro dimensione \`e un multiplo di due, sia pagine che frame hanno la stessa dimensione, da qualche parte andranno salvate le informazioni di mapping tra pagine e frame, si utilizza un \textbf{frame table}, dove ogni riga corrisponde una mappatura. Anche utilizzando la paginazione si ha frammentazione interna, l'ultima pagina soffrir\`a di frammentazione.

% TODO:  <28-02-23, yourname> rivedere, prendere immagini %
Una indirizzo generato dall CPU si divide in:
\begin{itemize}
  \item \textbf{numero di pagine (p)}: 
  \item \textbf{numro di offset (d)}:
  \item \textbf{numero di frame (f)}:
\end{itemize}
Un indirizzo \`e composto da: (p-d, d)
\begin{example}{}{}
  Se si hanno frame piccoli diminuisce la frammentazione ma aumentano anche le righe della tabella.
\end{example}
Nelle righe della tabelle si aggiungono dei bit in pi\`u:
\begin{itemize}
  \item parte di protezione, specifica che la parte di codice non pu\`o essere scritta;
  \item \textbf{modify bit}: pagina modifica;
  \item \textbf{page present/absent}: 
\end{itemize}
Come si implementa una page table? La page table si trova in memoria RAM, per sapere dove si trova si utilizzano due rigistri: \textbf{page table base register} e \textbf{base table lenght register}, infatti la base table si trova in memoria contigua. Per velocizzare questa operazione si utilizza che TLB che \`e pi\`u piccola e si trova direttamente sulla CPU, si usa la \textbf{Translation Look-aside Buffer} (TLB), un tipo di memoria in cui si accede per contenuto. Si aggiunge anche un altra informazione \textbf{ASID} in cui viene salvata l'infromazione del processo a cui la pagina appartiene, se non \`e presente questa informazione si i processi si contentendono la TLB. Quando avviene un \textbf{TLB miss} se reinserisce nella TLB e poi si ritenta, utilizzando una politica scelta.
\begin{center}
  \emph{Lo schema finale \`e la combinazione di TLB e page table.}
\end{center}
Il \textbf{Tempo di accesso effettivo} (EAT) in memoria \`e il tempo che mi costa accedere alla RAM:
\[ EAT = h \cdot M + (1 - h) \cdot 2M  \]
\begin{itemize}
  \item $h$ = TLB hit ratio;
  \item $M$ = Memory access time;
\end{itemize}
La protezione \`e implementata associando un bit di protezione per un frame specifico, e quindi per la rispettiva pagina, grazie a questo bit si possono definire parti ci codice che indica che il frame \`e in solo scrittura. Anche un altro bit associato \`e \textbf{validity} che indica quando una pagina \`e valida, ovvero quando c'\`e ed \`e associata ad un frame, o quando una pagina non \`e valida che vuol dire che la pagina non esiste o che non \`e associata ad frame, se si cerca di accedere una pagina non valida viene lanciata una \textbf{trap}.

La tabella della pagina permette di \textbf{condividere le pagine} (anche se in realt\`a sono i frame), se pi\`u processi hanno delle pagine che sono comuni vengono condivise da entrambi i processi.

La page table \`e una struttura dati del kernel:
\begin{example}{}{}
  HP: spazio logico di indirizzamento di 32 bit, una pagina di 4KB ($2^{12}$), la page table avr\`a un milione di entry ($2^{32}/2^{12}$), ogni entry della page table sono 4bytes, quindi una pagetable \`e grande 4MB. Adesso \`e possibile avare:
  \begin{itemize}
    \item \textbf{page table contigua}:
      \begin{itemize}
        \item dimensione critica (troppo grande):
          \begin{itemize}
            \item page table gerarchica;
            \item hash page table;
            \item inverted page table;
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{example}
La \textbf{la page table gerarchica}, la page table viene divisa in blocchi pi\`u piccoli non contigui, se usa una page table di livello superiore che porte alle page table di livello inferiore, questi blocchi devono rimanere contigui, anche se diventano molto piccoli. Il page number viene diviso in due parti, una per la tabella outer ed una per la tabella inner (pu\`o avere anche pi\`u di due livelli), quando si va su 64 bit e la outer dienta molto grande si pu\`o usare solo una parte dell'indirizzamento se l'eseguibili \`e molto piccolo.

La \textbf{hashed page table} permette di creare una tabella di hash, con una funzione direttamente implementata in hardware che dato $p$ in input ritorna $f$. Vanno implementate delle liste di collisione, e quindi vieni immagazzinato che $p$ che \`e la chiave di accesso. Usando una tabella di hash si potrebbe pensare anche di usare una page table condivisa tra tutti i processi, ma a quel punto va inserito anche l'ID del processo.

La \textbf{inverted page table} \`e una tabella condivisa tra tutti i processi, la sua grandezza viene dimensionata sulla grandezza della RAM e non sulla grandezza dei processi, in cui ogni frame fisico \`e associata una pagina, in questo caso le entry che corrisponde ad un frame ritorna la pagina a cui \`e associto, il problema che si vuole la traduzione da pagine ad entry e non il contrario, la prima strategia che si pu\`o utilizzare \`e la scansione lineare. Per rendere l'accesso pi\`u veloce viene messa una tabella di hash prima di arrivare alla tabella invertita.


\subsection{Swapping}
Si suppunga che ad un certo punto si volgia far partire un processo e che la memoria sia piena, cosa si pu\`o fare? Una soluzione \`e lo \textbf{swapping}, ovvere viene rimesso sul backing store (in modo temporaneo) che in linux \`e la partizione di swap, e viene caricato il nuovo processo, grazie allo swapping si possono avere processi che hanno pi\`u memoria occupata di quanto la RAM sia grande.
\begin{example}{}{}
  Qunato costa il \textbf{context switch}? Memoria piena e viene fatto partire un programma, dunque deve essere portato un processo nel backing store. 100MB da fare la swap con velocit\`a di trasferimento di 50MB/sec.
  \begin{itemize}
    \item swap out = 2000ms
    \item pi\`u swap in dello stessa grandezza
    \item il tempo totole \`e di 4s
  \end{itemize}
  Se il porcesso sta fendo IO non si pu\`o fare lo swap out, una soluzione \`e non spostare un processo che sta facendo IO e spanane un altro, oppure usare un buffer del kernel.
\end{example}
Sui telefoni non esiste lo swaping, vengono in auito le \textbf{lifecycle dei contesti}. Il vantaggio di fare swapping \`e l'utilizzo del \textbf{paging swapping}, dove il swap in/out divento page in/out, dove vengono trasferite solo le pagine e non l'intero processo.

\subsection{Esercizi}
\begin{example}{}{}
  \begin{itemize}
    \item memoria fisica da 512MB
    \item allocazione minima 64B
    \item 128MB al SO
    \item tabella dei processi contiene: contiene indirizzo iniziale e size
    \item allocazione worst fit
    \item partizioni libere sono contenute in lista ordinata con dimensione descrescente
    \item 
  \end{itemize}
  Si supponga ...
\end{example}
\begin{example}{}{}
  Si descrivano brevemente 
  \begin{itemize}
    \item tlb: 0.9 hit ratio
    \item page table a due livelli
    \item indirizzo in tre parti, 10 11 11 bit
    \item 
  \end{itemize}
  Si fa una outer con cui si utillizzano 10bit, ed una inner con 11bit. Per calcolare il numero di inner ci sono due strade, il numero di byte preciso che contengono 100MB oppure si prende la prima potenza di 2 che contiene 100MB. Il resto delle righe delle outer overanno l'invalid bit settato ad 1.
\end{example}



\newpage
\section{Memoria Virtuale}
Con \textbf{memoria virtuale} si indica che delle pagine esistono solo virtualemente ma non fisicamente, in questo modo si vuole supportare uno spazio di indirizzamento pi\`u grande dello spazio di indirizzamento fisico. Si parte dalla premessa che \emph{un programma non bisogna di essere tutto in memoria per essere esguito}, si pensa ad un programma parzialmente caricato in memoria, dunque le mamoria di un programma non \`e pi\`u vincolato dalla grandezza della RAM, in questo caso si parla di \textbf{memoria virtuale}. Avere questa memoria virtuale porta una serie di vantaggi che volocizzano tutte le operazioni di IO tra la RAM e la memoria secondaria. La conseguenza \`e che viene introdotta la \textbf{demand paging}, ovvero che un pagina viene caricata solo quando \`e richiesta. Il \textbf{demand paging} \`e molto simile allo swapping, infatti il caso limite \`e il \textbf{lazy swapper} dove inizialmente non si ha nessun frame caricato, e ogni richiesta viene preso un frame.






\newpage
\section{Rust}
Rust \`e un linguaggio di programmazione moderno, che non permette di avere undefined behaveiur e soprottuto \`e un linguaggio \textbf{statically strongly typed}, inlotre \`e capace di inferire i tipi di dati in modo molto potente. Rust fornisce delle \emph{astrazioni a costo nullo}, ed \`e anche \emph{interoperabile} con C. La memoria in rust \`e gestita dal programmatore solo in parte, il motivo \`e che il complilatore forza il programmatore a scrivere del codice senza errori, ed il compilatore si occupa di effettuare la gestione della memoria. Esempio di \textbf{dangling pointer} in C.
\begin{lstlisting}[language=c]
typedef struct Dummy { int a; int b; } Dummy;

void foo(void) {
  Dummy *ptr = (Dummy *)malloc(sizeof(Dummy));
  Dumyy *alias = ptr;
  ptr->a = 2048;
  free(ptr);
  alias->b = 25;  // WARNING!!
  free(alias);
}
\end{lstlisting}
Grazie alle feature di rust si possono prevenire:
\begin{itemize}
  \item \textbf{dangling pointers}
  \item \textbf{doppi rilasci}
  \item \textbf{corse critiche}
  \item \textbf{buffer overflow}
  \item \textbf{iteratori invalidi}
  \item \textbf{overflow aritmetici}
\end{itemize}
Inoltre rust propone delle convenzioni per aiutare il programmatore ad avere del codice ideomatico.

Rust parte dall'assunzoine che un valore pu\`o essere \textbf{posseduto} da una singola variabile, se la variabile esce al di fuori del suo scope il valore viene deallocato. Quando si fanno delle assegnazioni l'\textbf{ownership} del valore viene trasferito alla variabile alla quale \`e stata fatto l'assegnazione, inoltre \`e anche possibile \textbf{dare in presetito} (\textbf{borrow}) un valore; l'insieme di queste idee sono alla base della sicurezza che fornisce Rust. I puntatori sono tutti controllati in fase di compilazione, oltre all'\textbf{ownership} ogni puntatore ha un \textbf{tempo di vita} (\textbf{lifetime}), tutti gli accessi al di fuori della lifetime sono negati dal compilatore, in alcuni casi non pu\`o essere fatto l'infering della lifetime e questo andr\`a specificato esplicitamente usando la notazione \texttt{<'...>}. La \textbf{sicurezza dei thread} \`e incorporata nel sistema dei tipi e anch'essi hanno una lifetime. Rust inoltre non ha stati nascosti, come in java con le eccezioni.

I due strumenti per gestire l'ambiente di sviluppo in rust sono:
\begin{itemize}
  \item \texttt{\$ rustup}: installer and updater di rust;
  \item \texttt{\$ rustc}: compilatore;
  \item \texttt{\$ cargo}: gestione dei progetti e delle dipendenze;
\end{itemize}
I comandi di base di \texttt{cargo} sono:
\begin{itemize}
  \item \texttt{\$ cargo new project-name}
  \item \texttt{\$ cargo new --lib library-name}
  \item \texttt{\$ cargo build}
  \item \texttt{\$ cargo run}
\end{itemize}
Terminologia in rust:
\begin{itemize}
  \item \textbf{crate}: unit\`a di compilazione, crea un eseguibile o una libreria;
  \item \textbf{create root}: radice del progetto e solitamente contiene il \texttt{main.rs}, oppure \texttt{lib.rs} in caso di librerie;
  \item \textbf{module}: il progetto \`e organizzato in \emph{moduli}, se si crea un modulo come cartella il file .rs andr\`a nominato \texttt{mod.rs}, all'interno possono essere presenti moduli interni;
  \item \textbf{package}: 
\end{itemize}
Come in kotlin i blocchi condizionali hanno dei valori di ritorno. In rust non esiste l'eriditarit\`a, per\`o esistono i \textbf{trait}, che sono simili alle interfacce, offrendo la possibilit\`a di poter implementare dei metodi, ad esempio alcuni di questi sono \texttt{Display} e \texttt{Debug}, ogni tipo pu\`o implementare pi\`u tratti.

I tipi elementari di rust sono:
\begin{itemize}
  \item numerici: \texttt{i8, i16, i32, i64, i128, isize} (valore nativo del processore).
  \item numerici senza segno: \texttt{u8, ...}
  \item naturali: \texttt{f32, f64}
  \item logici: \texttt{bool}
  \item caratteri: \texttt{char} (32 bit, rappresentazione \textbf{Unicode})
  \item unit: \texttt{()} rappresenta una tupla di 0 elementi, corrisponde a \texttt{void} in C/C++
\end{itemize}
Per rappresentare le stringhe invece si use la codifica \texttt{utf-8}, che codifica i caratteri unicode in blocchi di 8 bit, la codifica utilizza la maggior parte dei primi 8 bit come caratteri standard, se si vogliono usare simboli pi\`u strani si combina un byte con il successivo, se il carattere \`e ancora pi\`u raro si utilizzano pi\`u byte, fino ad arrivare a 4. 

\hfill

Una \textbf{tupla} \`e una struttura che permette di contenere pi\`u tipi di valori, per accedere alla posizione corrispondente si utilizza la notazoine \texttt{<variabile>.<numero>}.

\hfill

Rust ha un meccanismo al suo interno per rappresentare i puntatori, infatti quando viene creato un valore in una funzione si pu\`o decidere di passare l'ownership alla funzione chiamante, che poi ha la responsabilit\`a di liberla oppure di passare ancora l'ownership, in rust esistono tre tipi di puntatori:
\begin{itemize}
  \item \textbf{reference};
  \item \textbf{box};
  \item \textbf{native pointer};
\end{itemize}
L'utilizzo dei puntatori nativi (che sono gli stessi del C), \`e possibile solo in un blocco \verb|unsafe { ... }|.

Le \textbf{reference} sono puntatori senza possesso e possono essere assegnati con \texttt{\&}:
\begin{lstlisting}[language=rust]
let r1 = &v;
let r1 = &mut v;
\end{lstlisting}
In questo caso \texttt{r1} borrows il valore \texttt{v}, per acceder al valore si utilizza la notazione per \textbf{derefenziare}: \texttt{*r1}. Quando si crea un puntatore che \texttt{\&} si pu\`o un creare un puntatore in sola lettura, si vuole anche scrivere all'indirizzo del puntatore si deve usere la keyword mut: \texttt{\&mut v}, l'accesso in scrittura \`e \emph{esclusivo}, ovvero pu\`o essere assegnato ad una sola variabile e quando viene asseganto in modo mutabile nussun altro pu\`o utilizzarlo, infatti \`e \emph{mutuamente esclusivo}.
\begin{lstlisting}[language=rust]
fn main() {
  let mut i = 32;

  let r = &i;     // r is of type "int ref";
  println!("{}", *r);

  i = i+1;        // ERROR: i was borrwed
  println!("{}", *r);
}
\end{lstlisting}
\begin{lstlisting}[language=rust]
fn main() {
  let mut i = 32;

  let r = &mut i;
  println!("{}", i);  // ERROR: i was mutably borrowed

  *r = *r+1;
  println!("{}", *r);
}
\end{lstlisting}
In questo caso la variabile \texttt{i} non \`e accessibile in alcun modo per tutta l'esistenza di \texttt{r}.

In altre situazioni c'\`e l'esigenza di allocare un dato, per prolungare la sua vita all'infuori della funzione in cui viene creato, l'equivalente della \texttt{malloc} in rust \`e \texttt{Box<T>} che alloca un parte di memoria presa dall'\emph{heap}, per creare un valore che che si vuole venga conservato, si passa a \texttt{Box} il valore che voglio si venga conservato:
\begin{lstlisting}[language=rust]
let b = Box::new(v);
\end{lstlisting}
Rust \`e in grado di fare l'infer del tipo di \texttt{v} e riesce ad allocare lo spazio necessario, quando \texttt{b} non sar\`a pi\`u visibile il \texttt{Box} verr\`a liberato dalla memoria.
\begin{lstlisting}[language=rust]
fn useBox() {
  let i = 4;                      // i si trova nello stack
  let mub b = Box::new((5, 2));   // *b si trova nell'heap, b si trova nello stack

  (*b).1 = 7;

  println!("{:?}", *b);   // (5, 7)
  println!("{:?}", b);    // (5, 7)
}
\end{lstlisting}
Quando \texttt{println!} si trova un puntatore lo dereferenzia automaticamente. Quando si arriva alla fine della funzione \texttt{a} e \texttt{b} vengono rimossi dallo stack, dato che il valore a cui puntava \texttt{b} non possiede un owner in vista quel valore viene rimosso dell'heap.
\begin{lstlisting}[language=rust]
fn makeBox(a: i32) -> Box<(i32,i32)> {
  let r = Box::new((a, 1));
  return r;
}

fn main() {
  let b = makeBox(5);
  let c = b.0 + b.1;
}
\end{lstlisting}
In questo caso il valore l'ownership del valore puntato da \texttt{r} passa la sua ownership a \texttt{b} che si trova nel \texttt{main}, quando il \texttt{main} termina e la vita di \texttt{b} finise il valore puntato viene anch'esso liberato.

I \textbf{Puntatori nativi} sono \texttt{*const T} e \texttt{*mut T}, il \texttt{*} indica un puntatore nativo e possono essere utilizzati solo nei blocchi \texttt{unsafe { ... }}.

Rust supporta nativamente anche gli \textbf{array}, in rust gli array sono composti da dati omogenei allocati contiguamente nello stack. Si possono inizializzare nel seguente modo:
\begin{lstlisting}[language=rust]
let a: [i32; 5] = [1, 2, 3, 4, 5];
let b = [0; 5];     // array lungo 5, inizializzato a 0
\end{lstlisting}
In rust gli array hanno la conoscenza di quanto sono lunghi. Se si cerca di accedere ad indice fouri dal range di utilizzo rust fa \texttt{panic}, se \texttt{panic} viene lanciato in nel thread principale il programma termina, se viene lanciato in un altro thread viene terminato il thread. Per accedere all'array si utilizzano gli \textbf{Slice} (invece di utilizzare i puntatori), che vengono creati come riferimento ad una porzione di un array:
\begin{lstlisting}[language=rust]
let a = [1, 2, 3, 4];
let s1: &[i32]  = &a; // s1 contiene 1, 2, 3, 4
let s2 = &a[0..2]     // s2 contiene 1, 2
let s3 = &a[2..]      // s3 contitne 3, 4
\end{lstlisting}
Per questa sua natura viene detto \textbf{fat pointer}, perch\`e oltre a contenere il puntatore contiene anche la lunghezza. Come nel caso degli array se si va al di fuori del range viene generato un \texttt{panic}.

Il problema degli array \`e che quando vengono creati con una dimensione, questa rimane fino alla del loro lifetime, un array variabile pu\`o essere creato con \texttt{Vec<T>} che rappresenta una sequenza di oggetti di tipo \texttt{T}, al contrario degli array gli oggetti presenti in \texttt{Vec} sono allocati nell'heap.
\begin{lstlisting}[language=rust]
fn useVec() {
  let mut v: Vec<i32> = Vec::new();

  v.push(2);
  v.push(4);

  let s = &mut v;
  s[1] = 8;
}
\end{lstlisting}
Quando viene inizializzato \texttt{Vec} nello stack vengono inseriti 3 parametri: pointer, size, capacity. Appena viene fatto push viene allocata della memoria nell'heap, e i parametri size e capacity vengono aggiornati. Se vuole creare uno slice \texttt{s}, nello stack viene messo un fat pointer, ovvere il puntatore all'heap ed il size corrente. Quando \texttt{Vec<T>} viene inizialmente inizializzato, nel campo puntatore viene inserito l'allinemento che il tipo \texttt{T} dovr\`a avere in memoria.

Lo stesso discorso fatto per i \texttt{Vec} vale per gli oggetti di tipo \texttt{String}. Quando si crea una stringa tra le virgolette viene creato un \texttt{\&str} e non una \texttt{String}, questo dato andr\`a inserito nella sezione del programma dei \emph{dati inizializzati}, al contrario delle \texttt{String} queste non modificabili, se si vuole utilizzare una stringa si utilizza \texttt{"...".as\_str()}, che ritorna uan stringa allocata nell'heap.
\begin{lstlisting}[language=rust]
fn main() {
  let hello: &str = "hello";

  let mut s = String::new();    // il valore (futuro) puntato da s viene allocato nell'heap

  s.push_str(hello);            // l'heap viene inizializzato una capacita' ed un size uguale al size della stringa puntata da "hello"
  s.push_str(" world!");
}
\end{lstlisting}
In rust le keyword \texttt{let} e \texttt{let mut} sono delle istruzioni, mentre un blocco racchiuso tra \texttt{{ ... }} \`e un espressione e quindi ha un valore di ritorno, anche il costrutto \texttt{if} \`e un espressione, \textbf{il valore viene ritornato a patto che l'ultima istruzione del blocco non abbia un punto e virgola}. Si pu\`o asseganre un etichetta con \texttt{'<nome-etichetta>:} ad un espressione per poter specificare il ritorno:
\begin{lstlisting}[language=rust]
fn main() {
  'outer: loop {
    'inner: loop {
      //...
      continue 'outer;
    }
  }
}
\end{lstlisting}

Per leggere gli argomenti passati da linea di comando si utilizza:
\begin{lstlisting}[language=rust]
fn main() {
  let args: Vec<String> = args().skip(1).collect();

}
\end{lstlisting}
Si pu\`o utilizzare la libreria \texttt{clap} per fare il parsing degli argomenti. per farlo si pu\`o andare nel file \texttt{.toml} ed inserire la dipendenza.


Per fare IO da console si utilizza \texttt{stdin}:
\begin{lstlisting}[language=rust]
fn main() {
  let mut s = String::new();

  if io::stdin().read_line(&mut s).is_ok() {
    println!(..., s.trim());
  } else {
    println!("Failed!");
  }

  // Oppure...
  io::stdin().read_line(&mut s).unwrap();
  println!(..., s.trim());
}
\end{lstlisting}


\subsection{Ownership}
Il concetto dell'ownership in rust permette al \textbf{borrow checker} di controllare l'utilizzo corretto dei puntatori, in rust \emph{un valore pu\`o essere posseduto da una e una sola variabile}, il fallimento di questa condizione comporta ad un fallimento della compilazione. Possere un valore vuol dire \emph{occuparsi del suo rilascio}. Se una variabile mutabile viene riasseganta, ed il valore precedente implementava il tratto \texttt{Drop} esso viene prima liberato e poi avviene l'assegnazione. Quando si fa un assegnazione da una variabile all'altra: \texttt{a = b}, il valore posseduto da \texttt{b} viene spostato in \texttt{a}, questa operazione viene detta \textbf{movimento}, ed il valore non \`e pi\`u accessibile da \texttt{b}, dal punto di vista fisico il movimento \`e una \emph{copia}.
\begin{lstlisting}[language=rust]
fn main() {
  let mut s1 = "hello".to_string();
  println!("s1: {}", s1);

  let s2 = s1;
  println!("s2: {}", s2);

  // s1 non e' piu' accessibile
}
\end{lstlisting}
Il movimento \`e il comportamento standard in rust, se per\`o un tipo implementa il tratto \texttt{Copy} quando avviene un'essegnazione entrabe le variabili possono continuare ad accedere al valore, per\`o i tratti \texttt{Copy} e \texttt{Drop} sono mutuamente esclusivi. In generale i tipi copiabili sono i: numeri, booleani, le reference \texttt{\&}, ..., mentre i \texttt{\&mut} non sono copiabili. Il tratto \texttt{Copy} pu\`o essere implementato solo se il tipo implementa il tratto \texttt{Clone}, che permette di fare una clonazione dell'oggetto \textbf{in profodit\`a}, inoltre la clonazione \`e implementata dal compilatore, mentre copia e movimento sono gestite dal compilatore e veine implementata con \texttt{memcpy()}.
\begin{lstlisting}[language=rust]
fn main() {
  let mut s1 = "hi".to_string();
  let s2 = s1.clone();  // viene creato nello stack una nuova variabile e nell'heap un nuovo valore
  s1.push('!');

  println!("s1: {}", s1); // hi!
  println!("s2: {}", s2); // hi
}
\end{lstlisting}
In rust il comportamento di base \`e il movimento, mentre in C l'unico comportamento \`e quello della copia, mentre in C++ si pu\`o copiare e si pu\`o muovere ma questo va scritto esplicitamente.
\begin{lstlisting}[language=rust]
struct Test(i32);

impl Drop for Test {
  fn drop(&mut self) {
    println!("Dropping Test({}) @ {:p}", self.0, self);
  }
}

fn alfa(t: Test) {
  println!("Invoking alfa() with Test({}) @ {:p}", t.0, &t);
}

fn main() {
  let t = Test(12);

  alfa(t);

  println!("Ending...");
}
\end{lstlisting}
Quello che succede in questo caso \`e che il metodo di \texttt{drop()} viene chiamato scritto prima di \texttt{Ending...}, il motivo \`e che \texttt{t} viene mossa all'interno della funzione \texttt{alfa()}. Quando non si vuole passare la propriet\`a del valore ad una funzione si pu\`o decidere di \textbf{prestarglielo}, se si vuole fare ci\`o l'argomento della funzione deve essere una reference.
\begin{lstlisting}[language=rust]
fn alfa(t: &Test) {
  println!("Invoking alfa() with Test({}) @ {:p}", t.0, t);
}

fn main() {
  let t = Test(12);

  alfa(&t);

  println!("Ending...");
}
\end{lstlisting}
Se si vuole modificare il valore all'interno della funzione si cambiare la firma in: \texttt{fn alfa(t: \&mut Test)}.

\hfill

In rust i riferimenti permettono il prestito dei valori di una variabile in solo scrittura, mentri i riferimenti mutabili permettano lettura e scrittura, ma se viene prestato la variabile originale non pu\`o leggere.
% TODO:  <10-03-23, yourname> mettere immagine %
A differenza del tipo di dato che si maneggia, si possono avere 3 tipi di puntatori: \textbf{reference}, \textbf{fat pointer}, \textbf{double pointer}. Quando il compilare ha tutte le informazioni sul tipo di dato ho bisogno di una reference semplice, se tuttavia non \`e in grado di inferire tutti i dati ricorre ad un \emph{fat pointer} (come nelle slice), che contiene il puntatore all'oggetto e la dimensione dell'oggetto. Nel caso di un tipo che contiene delle implementazioni, viene usato un double pointer, dove il primo punta all'oggetto, ed il secondo punta alla \textbf{vtable}, questa \`e una tabella che contiene i puntatori alle funzioni che vengono implementati per un tratto, ed esiste una vtable per ogni tratto implementato.
\begin{lstlisting}[language=rust]
let f: File = File::create("text.txt");
let r3: &dyn Write = &f;   // double pointer
\end{lstlisting}
Il borrow checker garantisce che tutti gli accessi ad un riferimento avvengano solo all'interno di una \textbf{lifetime}, in alcuni casi il complilatore non \`e in grado di fare l'infering della lifetime, per assegnare una lifetime ad un riferimento si utilizza la sintassi:
\begin{lstlisting}[language=rust]
&'a Type
\end{lstlisting}
L'unico nome riservato \`e \texttt{\&'static Type}, questo vuol dire che la lifetime di quella reference sopravvive per l'intera durata del programma.

\subsection{Slice}
Uno slice \`e una vista su una sequenza contigua di elementi, gli slice in queanto riferimento non possiedono il valore, oltre ad essere dei fat pointer.

































\end{document}

%% vim: ts=2 sts=2 sw=2 et
